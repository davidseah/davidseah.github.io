---
layout: post
title: "List of C++ 11 Topics"
categories: CPP
tags: [documentation,sample]
image:
  feature: 
  teaser:  
  credit: 
  creditlink: ""
---
Recently I have read the daily email send by John Sonmez with regards to learning. 
Most programmers simply just drive straight into a topic with a plan on whatever they are going to learn. 
Not only does this makes you unproductive, it gives unmotivates you too. 

Instead what you need to do is to have the desired outcome in mind and have a plan that brings you to your destination. 
Having that in mind, I asked myself? What do I kind of outcome do I want to see myself? I have been coding C++ from closing to 6 years. 
C++11 came out around 5 years ago, and I have always wanted to learn the concepts of modern C++. But really, I wasn't able to. 
Either what I already know was enough, or I simply couldn't get past the stage of being stuck on a certain topic. 
Going through the C++ primer book, it has a list of C++ topics nicely listed down. 

My plan is to list down all the C++11 topics and I am going to write a post about each topic. 

My aim is that by the time, I covered all these C++11 topics, I am proficient enough to code in modern C++. 

<h2>C++ 11 Topics</h2>
* [long long Type]({% post_url 2017-09-17-Long-Long-Type %})
* [List Initialization]({% post_url 2017-12-9-C++_List_Initailization %})
* nullptr Literal
* constexpr Variables 
* Type Alias Declarations
* The auto Type Specifier 
* The decltype Type Specifier 
* In-Class Initializers 
* Using auto or decltype for Type Abbreviation 
* Range for Statement 
* Defining a vector of vectors
* List Initialization for vectors
* Container cbegin and cend Functions
* Library begin and end Functions
* Using auto or decltype to Simplify Declarations
* Rounding Rules for Division
* Assignment from a Braced List of Values
* sizeof Applied to a Class Member
* Range for Statement
* Library initializer_list Class
* List Initializing a Return Value
* Declaring a Trailing Return Type
* Using decltype to Simplify Return Type Declarations
* constexpr Functions
* Using = default to Generate a Default Constructor
* In-class Initializers for Members of Class Type 
* Delegating Constructors 
* constexpr Constructors 
* Using strings for File Names
* The array and forward_list Containers
* Container cbegin and cend Functions
* List Initialization for Containers 
* Container Nonmember swap Functions 
* Return Type for Container insert Members 
* Container emplace Members
* shrink_to_fit 
* Numeric Conversion Functions for strings 
* Lambda Expressions 
* Trailing Return Type in Lambda Expressions 
* The Library bind Function 
* List Initialization of an Associative Container 
* List Initializing pair Return Type
* List Initialization of a pair
* The Unordered Containers 
* Smart Pointers 
* The shared_ptr Class 
* List Initialization of Dynamically Allocated Objects 
* auto and Dynamic Allocation 
* The unique_ptr Class
* The weak_ptr Class
* Range for Doesn’t Apply to Dynamically Allocated Arrays
* List Initialization of Dynamically Allocated Arrays
* auto Can’t Be Used to Allocate an Array
* allocator::construct Can Use any Constructor 
* Using = default for Copy-Control Members 
* Using = delete to Prevent Copying Class Objects
* Moving Instead of Copying Class Objects
* Rvalue References
* The Library move Function
* Move Constructor and Move Assignment
* Move Constructors Usually Should Be noexcept 
* Move Iterators 
* Reference Qualified Member Functions 
* The function Class Template
* explicit Conversion Operators
* override Specifier for Virtual Functions
* Preventing Inheritance by Defining a Class as final
* override and final Specifiers for Virtual Functions
* Deleted Copy Control and Inheritance
* Inherited Constructors
* Declaring a Template Type Parameter as a Friend
* Template Type Aliases
* Default Template Arguments for Template Functions
* Explicit Control of Instantiation
* Template Functions and Trailing Return Types 
* Reference Collapsing Rules 
* static_cast from an Lvalue to an Rvalue
* The Library forward Function
* Variadic Templates and Forwarding
* The Library Tuple Class Template 
* New bitset Operations
* The Regular Expression Library 
* The Random Number Library
* Floating-Point Format Control
* The noexcept Exception Specifier 
* The noexcept Operator
* Inline Namespaces
* Inherited Constructors and Multiple Inheritance
* Scoped enums
* Specifying the Type Used to Hold an enum 
* Forward Declarations for enums
* The Library mem_fn Class Template
* Union Members of Class Types 
  
  
  